---
title: Swarm Mail
description: Event-sourced messaging system for multi-agent coordination
---

```
                                  _.------._
                                .'   .--.   '.        ğŸ
                               /   .'    '.   \    ğŸ
                              |   /   __   \   |      ğŸ
    ğŸ                        |  |   (  )   |  |  ğŸ
         ğŸ    _  _           |  |   |__|   |  |
              ( \/ )           \  '.      .'  /    ğŸ
    ğŸ    ____/    \____        '.  '----'  .'
        /    \    /    \         '-._____.-'           ğŸ
       /  ()  \  /  ()  \
      |   /\   ||   /\   |     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
      |  /__\  ||  /__\  |     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
       \      /  \      /      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
    ğŸ  '----'    '----'       â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
                               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
          ğŸ                   â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•
                 ğŸ
    ğŸ                         â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—
                               â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘         ğŸ
         ğŸ                    â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘
                               â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    ğŸ
    ğŸ        ğŸ               â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
                               â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•â•â•â•â•â•       ğŸ
              ğŸ
                          âš¡ Actor-Model Primitives for Agent Coordination âš¡
```

## Overview

**Swarm Mail** is an embedded, event-sourced messaging system for multi-agent coordination. Built on **Durable Streams** primitives with Effect-TS, it provides actor-model communication without external server dependencies.

## What Problem Does It Solve?

When multiple AI agents work on the same codebase in parallel, they need to:

- **Coordinate file access** - prevent edit conflicts via reservations
- **Exchange messages** - async communication for status, blockers, handoffs
- **Request/response** - synchronous-style RPC for data queries
- **Resume after crashes** - positioned consumption with checkpointing
- **Audit all actions** - full event history for debugging and learning

Traditional solutions require external servers (Redis, Kafka, NATS). Swarm Mail is **embedded** - just libSQL (embedded SQLite) + Effect-TS.

## Key Features

- âœ… **Local-first** - No external servers, no network dependencies
- âœ… **Event-sourced** - Full audit trail of all agent actions
- âœ… **Resumable** - Checkpointed cursors for exactly-once processing
- âœ… **Type-safe** - Effect-TS with full type inference
- âœ… **Actor-model** - Mailboxes, envelopes, distributed promises
- âœ… **File safety** - CAS-based locks for mutual exclusion
- âœ… **Semantic memory** - Vector embeddings for persistent agent learning

---

## Architecture Stack

Swarm Mail is built in **3 tiers** - primitives, patterns, and coordination layers.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              SWARM MAIL STACK                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   TIER 3: COORDINATION                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ask<Req, Res>() - Request/Response over Streams (RPC-style)        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                      â”‚
â”‚   TIER 2: PATTERNS                   â–¼                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚   â”‚    DurableMailbox     â”‚    â”‚     DurableLock       â”‚                    â”‚
â”‚   â”‚  Actor Inbox + Reply  â”‚    â”‚  CAS Mutual Exclusion â”‚                    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚              â”‚                           â”‚                                  â”‚
â”‚   TIER 1: PRIMITIVES                     â–¼                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚   â”‚    DurableCursor      â”‚    â”‚   DurableDeferred     â”‚                    â”‚
â”‚   â”‚  Checkpointed Reader  â”‚    â”‚  Distributed Promise  â”‚                    â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚              â”‚                           â”‚                                  â”‚
â”‚   MEMORY                                 â–¼                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  Semantic Memory - Vector embeddings (pgvector) + Ollama            â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                      â”‚
â”‚   STORAGE                            â–¼                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚              libSQL (Embedded SQLite) + Migrations                  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Quick Start

### Installation

```bash
npm install swarm-mail
```

### Initialize Agent

```typescript
import { Effect } from "effect";
import { DurableAskLive } from "swarm-mail/streams/effect/layers";
import {
  initSwarmAgent,
  sendSwarmMessage,
  reserveSwarmFiles,
} from "swarm-mail";

const program = Effect.gen(function* () {
  // 1. Initialize agent
  const { agentName, projectKey } = yield* Effect.promise(() =>
    initSwarmAgent({
      projectPath: "/abs/path",
      taskDescription: "bd-123.2: Auth service",
    }),
  );

  console.log(`Agent: ${agentName}`); // e.g., "DarkStone"

  // 2. Reserve files
  const { granted, conflicts } = yield* Effect.promise(() =>
    reserveSwarmFiles({
      projectPath: projectKey,
      agentName,
      paths: ["src/auth/**"],
      reason: "bd-123.2: Auth service",
      exclusive: true,
    }),
  );

  if (conflicts.length > 0) {
    console.warn("File conflicts detected:", conflicts);
  }

  // 3. Report progress
  yield* Effect.promise(() =>
    sendSwarmMessage({
      projectPath: projectKey,
      fromAgent: agentName,
      toAgents: ["coordinator"],
      subject: "Progress: bd-123.2",
      body: "Reserved files, starting work",
      threadId: "bd-123",
      importance: "normal",
    }),
  );

  // 4. Do work...
  yield* Effect.sleep("5 seconds");

  // 5. Report completion
  yield* Effect.promise(() =>
    sendSwarmMessage({
      projectPath: projectKey,
      fromAgent: agentName,
      toAgents: ["coordinator"],
      subject: "Complete: bd-123.2",
      body: "Auth service implemented",
      threadId: "bd-123",
      importance: "high",
    }),
  );
});

Effect.runPromise(program.pipe(Effect.provide(DurableAskLive)));
```

---

## Event Sourcing Architecture

Swarm Mail is fully event-sourced. **All state changes are events first, materialized views second.**

### Event Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Action    â”‚  Agent calls API (e.g., sendMessage)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Create    â”‚  createEvent("message_sent", {...})
â”‚   Event     â”‚  Returns: { type, timestamp, ...payload }
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Append    â”‚  appendEvent() â†’ INSERT INTO events
â”‚   to Log    â”‚  Gets auto-increment id + sequence
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Update    â”‚  updateProjections() triggers based on event type
â”‚   Views     â”‚  - message_sent â†’ INSERT messages, UPDATE agent read status
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  - file_reserved â†’ INSERT reservations
       â”‚         - message_read â†’ UPDATE message read flags
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Query     â”‚  getInbox(), getMessage(), getReservations()
â”‚   Views     â”‚  Fast queries on materialized tables
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Event Types

| Event Type         | Trigger                      | Projections Updated              |
| ------------------ | ---------------------------- | -------------------------------- |
| `agent_registered` | Agent init                   | `agents` table                   |
| `message_sent`     | sendMessage()                | `messages`, `message_recipients` |
| `message_read`     | readMessage(markAsRead=true) | `messages.read_by` JSONB         |
| `message_acked`    | acknowledgeMessage()         | `messages.acked_by` JSONB        |
| `file_reserved`    | reserveFiles()               | `reservations`                   |
| `file_released`    | releaseFiles()               | `reservations` (DELETE expired)  |

### Why Event Sourcing?

- âœ… **Full audit trail** - every agent action is logged forever
- âœ… **Time travel** - replay events to reconstruct past state
- âœ… **Debugging** - when agents conflict, trace exact sequence of events
- âœ… **Learning** - analyze event patterns to improve swarm strategies
- âœ… **Resumability** - cursors checkpoint position, replay from there on crash

---

## Comparison to Agent Mail

Swarm Mail is **inspired by** [Agent Mail](https://github.com/sst/opencode) (SST's multi-agent coordination layer) but built from scratch with different trade-offs.

| Aspect                   | Agent Mail (SST)              | Swarm Mail (This Plugin)               |
| ------------------------ | ----------------------------- | -------------------------------------- |
| **Architecture**         | MCP server (external process) | Embedded (libSQL in-process)           |
| **Storage**              | SQLite file                   | libSQL (SQLite-compatible)             |
| **Dependencies**         | Requires MCP server running   | Zero external deps, just npm install   |
| **Effect-TS**            | No                            | Yes (full Effect integration)          |
| **Event Sourcing**       | No (CRUD operations)          | Yes (append-only event log)            |
| **Cursors**              | No (queries are one-shot)     | Yes (resumable positioned consumption) |
| **Distributed Promises** | No                            | Yes (DurableDeferred)                  |
| **Type Safety**          | MCP JSON-RPC (strings)        | Full TypeScript + Zod validation       |
| **Local-First**          | Requires server               | True local-first (no network)          |
| **Learning System**      | No                            | Yes (eval records, pattern maturity)   |

**When to Use Agent Mail:**

- You're already using OpenCode with MCP infrastructure
- You need cross-project coordination (multiple repos)
- You want battle-tested SST ecosystem integration

**When to Use Swarm Mail:**

- You want embedded, zero-config coordination
- You're building Effect-TS applications
- You need event sourcing and audit trails
- You want resumable cursors for exactly-once semantics
- You're using this plugin's learning/swarm features

---

## Database Schema

Swarm Mail uses **libSQL** (SQLite-compatible embedded database). Schema is managed via migrations.

### Core Tables

#### `events` - Append-Only Event Log

```sql
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  sequence SERIAL,              -- Auto-increment, never gaps
  type TEXT NOT NULL,           -- Event type (message_sent, file_reserved, etc.)
  timestamp BIGINT NOT NULL,    -- Unix timestamp in ms
  payload JSONB NOT NULL,       -- Event-specific data
  project_key TEXT NOT NULL,
  agent_name TEXT
);
CREATE INDEX idx_events_sequence ON events(sequence);
CREATE INDEX idx_events_type ON events(type);
CREATE INDEX idx_events_project ON events(project_key);
```

**All state changes flow through this table.** Other tables are materialized views.

See the [Primitives](/docs/packages/swarm-mail/primitives) documentation for detailed schema of each primitive's tables.

---

## Effect-TS Integration

Swarm Mail is **built with Effect** - a functional effect system for TypeScript.

### Why Effect?

- âœ… **Composability** - combine primitives into patterns without callback hell
- âœ… **Type inference** - full TypeScript inference for errors and dependencies
- âœ… **Retries** - built-in retry schedules with exponential backoff
- âœ… **Resource safety** - `Effect.ensuring` guarantees cleanup (like try/finally)
- âœ… **Dependency injection** - Layers for services, no globals

### Services and Layers

Each primitive is an Effect **Service** (via `Context.Tag`):

```typescript
// Define service interface
export class DurableCursor extends Context.Tag("DurableCursor")<
  DurableCursor,
  DurableCursorService
>() {}

// Implement service
export const DurableCursorLive = DurableCursor.of({
  create: createCursorImpl,
});

// Use service in Effect
const program = Effect.gen(function* () {
  const cursor = yield* DurableCursor; // Service dependency
  const consumer = yield* cursor.create({ stream: "..." });
  // ...
});

// Provide service implementation
Effect.runPromise(program.pipe(Effect.provide(DurableCursorLive)));
```

**Layers compose** - higher-level services depend on lower-level ones:

```typescript
// DurableMailbox depends on DurableCursor
const MailboxLayer = Layer.mergeAll(CursorLayer, DurableMailboxLive);

// Ask pattern depends on Mailbox + Deferred
export const DurableAskLive = Layer.mergeAll(DurableDeferredLive, MailboxLayer);

// Use in program
const program = Effect.gen(function* () {
  const mailbox = yield* DurableMailbox;
  const response = yield* ask({ mailbox, to: "worker-2", payload: {...} });
});

Effect.runPromise(program.pipe(Effect.provide(DurableAskLive)));
```

### Error Handling

Effect has **typed errors** - errors are part of the Effect signature:

```typescript
// Effect<Success, Error, Requirements>
type MyEffect = Effect.Effect<number, LockError | TimeoutError, DurableLock>;

// Handle specific error types
yield *
  lockService.acquire("resource").pipe(
    Effect.catchTag("LockTimeout", () => Effect.succeed(null)),
    Effect.catchTag("LockContention", () => Effect.fail(new MyError())),
  );
```

---

## Credits and Inspiration

- **[Kyle Matthews](https://twitter.com/kylemathews)** (Founder/CPO @ [Electric SQL](https://electric-sql.com/)) - The Durable Streams protocol and the insight that composable primitives can build powerful actor systems. [Original tweet](https://x.com/kylemathews/status/1999896667030700098)
- **[Agent Mail](https://github.com/sst/opencode)** - Multi-agent coordination layer for OpenCode (SST). Swarm Mail's API surface is heavily inspired by Agent Mail's design.
- **[Electric SQL](https://electric-sql.com/)** - Real-time sync engine for Postgres. The cursor pattern and positioned consumption ideas come from Electric's sync protocol.
- **[Effect-TS](https://effect.website/)** - Functional effect system powering the implementation. Effect's composability and type safety make the primitives ergonomic.

---

## What's Next?

Swarm Mail is **production-ready** but has room for optimization:

### Performance Improvements

- [ ] **Connection pooling** - reuse libSQL connections instead of opening new ones
- [ ] **Batch inserts** - batch multiple events into one transaction
- [ ] **Index tuning** - add covering indexes for hot queries

### Features

- [ ] **Message priorities** - priority queue for urgent messages
- [ ] **Dead letter queue** - failed messages go to DLQ for retry
- [ ] **Message TTL** - auto-expire old messages
- [ ] **Broadcast channels** - pub/sub for topic-based routing
- [ ] **Saga pattern** - distributed transactions with compensations

### Developer Experience

- [ ] **DevTools UI** - web UI for inspecting events, cursors, locks
- [ ] **CLI tools** - `swarm-mail inspect`, `swarm-mail replay`
- [ ] **Metrics** - Prometheus metrics for message latency, lock contention
- [ ] **Tracing** - OpenTelemetry spans for distributed tracing

---

```
    *    *  ğŸ  *    *
  *    *    *    *    *
    ğŸ   SHIP IT   ğŸ
  *    *    *    *    *
    *    *  ğŸ  *    *
```
