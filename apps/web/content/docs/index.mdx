---
title: Swarm Tools Documentation
description: Multi-agent coordination that survives context death and learns from outcomes
---

<div className="ascii-banner glow-amber mb-8">
```
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ•â•â•â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•     â•šâ•â•    â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
                                    ğŸ
```
</div>

Framework-agnostic primitives for building multi-agent AI systems. Works with Claude, GPT, Gemini, or any AI agent framework.

## The Problem

You're working with an AI coding agent. You ask it to "add OAuth authentication." It starts writing code. Five minutes later, you realize it's going down the wrong path. Or it's touching files it shouldn't. Or it's making changes that conflict with what you just did in another session.

**The fundamental issue:** AI agents are single-threaded, context-limited, and have no memory of what worked before.

## The Solution

What if the agent could:
- **Break the task into pieces** that can be worked on simultaneously
- **Spawn parallel workers** that don't step on each other
- **Remember what worked** and avoid patterns that failed
- **Survive context compaction** without losing progress

**That's what Swarm does.**

## How It Works

```
                            "Add OAuth"
                                 â”‚
                                 â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      COORDINATOR       â”‚
                    â”‚                        â”‚
                    â”‚  1. Query CASS         â”‚
                    â”‚  2. Pick strategy      â”‚
                    â”‚  3. Break into pieces  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼                     â–¼                     â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Worker A   â”‚       â”‚  Worker B   â”‚       â”‚  Worker C   â”‚
    â”‚ auth/oauth  â”‚       â”‚ auth/sessionâ”‚       â”‚ auth/tests  â”‚
    â”‚   ğŸ”’ files  â”‚       â”‚   ğŸ”’ files  â”‚       â”‚   ğŸ”’ files  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The **opencode-swarm-plugin** is what you install and use. It provides:

- **Task decomposition** - Breaks complex requests into parallel subtasks
- **File reservations** - Prevents edit conflicts between workers
- **Learning system** - Tracks what strategies work (fast + success = good, slow + errors = bad)
- **Skills** - Knowledge packages agents can load when needed
- **Beads** - Git-backed issue tracking integrated with swarm coordination

Under the hood, it uses **swarm-mail** for event sourcing and actor-model messaging. That's the infrastructure layerâ€”interesting if you're building your own coordination system, but you don't need to think about it to use the plugin.

## What Makes It Different

**1. Survives Context Death** âœ… *[Proven - 9 integration tests]*

When `swarm_progress` reports 25%, 50%, or 75% completion, an automatic checkpoint is created and stored in PGLite (embedded Postgres). If context compaction happens or an agent crashes, `swarm_recover` retrieves the last checkpoint with:

- Files modified so far
- Current strategy (file-based, feature-based, risk-based)
- Progress percentage
- Coordinator directives (shared context, skills to load, notes)
- Error context (if checkpoint happened during error handling)

No external database neededâ€”checkpoints persist in `.swarm-mail/` directory. Non-fatal failures mean work continues even if checkpoint fails.

**2. Learns From Outcomes**

Every completed task records learning signals:
- Fast completion + zero errors â†’ Pattern gets promoted
- Slow + retries + errors â†’ Pattern gets demoted
- >60% failure rate â†’ Pattern auto-inverts to anti-pattern

**3. Has Skills**

Bundled knowledge packages for common domains:
- `testing-patterns` - Feathers dependency-breaking techniques
- `swarm-coordination` - Multi-agent orchestration
- `cli-builder` - Argument parsing, help text, subcommands
- `learning-systems` - Confidence decay, pattern maturity

## Checkpoint & Recovery

The checkpoint system ensures no work is lost during context compaction or crashes.

### How It Works

**Automatic Checkpoints** - When `swarm_progress` reports:
- 25% completion â†’ First checkpoint saved
- 50% completion â†’ Midpoint checkpoint saved
- 75% completion â†’ Near-completion checkpoint saved

Each checkpoint stores:
```typescript
{
  files: ["src/auth.ts", "src/middleware.ts"],
  strategy: "file-based",
  progress_percent: 50,
  directives: {
    shared_context: "OAuth implementation notes",
    skills_to_load: ["testing-patterns"],
    coordinator_notes: "Watch for race conditions"
  },
  recovery: {
    last_checkpoint: 1234567890,
    files_modified: ["src/auth.ts"],
    error_context: "Optional: errors encountered"
  }
}
```

**Manual Checkpoints** - Workers can also create checkpoints explicitly:
```typescript
swarm_checkpoint({
  project_key: "/path/to/project",
  agent_name: "WorkerA",
  bead_id: "bd-123.1",
  epic_id: "bd-123",
  files_modified: ["src/auth.ts"],
  progress_percent: 30,
  directives: { /* optional */ },
  error_context: "Optional error details"
})
```

**Recovery** - Resume from last checkpoint:
```typescript
swarm_recover({
  project_key: "/path/to/project",
  epic_id: "bd-123"
})
// Returns: { found: true, context: { ... }, age_seconds: 120 }
```

### Storage

Checkpoints are stored in PGLite (embedded Postgres) at `.swarm-mail/` in your project directory. No external database needed. The `swarm_contexts` table tracks all checkpoints with full event sourcing for audit trail.

### Failure Handling

Checkpoint failures are **non-fatal**â€”if a checkpoint fails, work continues. You'll see a warning in logs but the agent keeps going. This prevents checkpoint infrastructure from blocking actual work.

## Quick Start

```bash
npm install -g opencode-swarm-plugin@latest
swarm setup
```

Then in OpenCode:

```typescript
/swarm "Add user authentication with OAuth"
```

The plugin queries past decompositions (via CASS), picks a strategy, creates beads, spawns workers, and tracks learning signals.

## Dependencies

### Required

| Dependency | Purpose |
|------------|---------|
| [OpenCode](https://opencode.ai) | AI coding agent (the plugin runs inside OpenCode) |
| [Beads](https://github.com/steveyegge/beads) | Git-backed issue tracking |

### Optional (Highly Recommended)

These tools significantly enhance the swarm experience:

| Tool | Purpose |
|------|---------|
| [CASS](https://github.com/Dicklesworthstone/coding_agent_session_search) | Historical context - queries past sessions for similar decompositions |
| [UBS](https://github.com/Dicklesworthstone/ultimate_bug_scanner) | Bug scanning - runs on subtask completion to catch issues |
| [semantic-memory](https://github.com/joelhooks/semantic-memory) | Learning persistence - stores patterns across sessions |

### Installing Optional Dependencies

#### CASS (Cross-Agent Session Search)

```bash
git clone https://github.com/Dicklesworthstone/coding_agent_session_search
cd coding_agent_session_search
pip install -e .
cass index  # Build the index (run periodically)
```

#### UBS (Ultimate Bug Scanner)

```bash
git clone https://github.com/Dicklesworthstone/ultimate_bug_scanner
cd ultimate_bug_scanner
pip install -e .
```

#### semantic-memory

Requires [Ollama](https://ollama.ai) with an embedding model:

```bash
# Install Ollama (macOS)
brew install ollama

# Start Ollama service
ollama serve

# Pull an embedding model
ollama pull mxbai-embed-large
```

The `semantic-memory_check` tool verifies Ollama is ready.

**Why install these?**

- **CASS** - When you run `/swarm "Add OAuth"`, the coordinator queries CASS for similar past tasks. Without it, decomposition is based only on the current task description.
- **UBS** - Every `swarm_complete` runs UBS to scan for bugs. Without it, you lose automatic bug detection.
- **semantic-memory** - Pattern maturity and anti-pattern detection persist across sessions. Without it, learning resets each session.

Run `swarm doctor` to check which dependencies are installed.

## What's Included

**opencode-swarm-plugin** - The plugin you install (40+ tools):

| Category | Tools | Purpose |
|----------|-------|---------|
| **Beads** | 8 tools | Git-backed issue tracking with atomic epic creation |
| **Swarm Mail** | 6 tools | Inter-agent messaging with file reservations |
| **Swarm** | 20+ tools | Task decomposition, parallel orchestration, learning |
| **Skills** | 4 tools | Knowledge injection with bundled domain expertise |

[View all plugin tools â†’](/docs/packages/opencode-plugin)

**swarm-mail** - Event sourcing infrastructure (used by the plugin):

If you're building your own agent coordination system, swarm-mail provides the primitives:

```bash
bun add swarm-mail
```

[View swarm-mail architecture â†’](/docs/packages/swarm-mail)

## Examples

### Swarm Coordination (Plugin)

```typescript
// In OpenCode, use the /swarm command:
/swarm "Add user authentication with OAuth"

// The plugin:
// 1. Queries CASS for similar past decompositions
// 2. Generates a strategy-specific decomposition
// 3. Creates epic + subtasks atomically
// 4. Spawns parallel worker agents
// 5. Tracks progress via Agent Mail
// 6. Records learning signals for future improvements
```

### File Reservations

```typescript
import { reserveSwarmFiles, releaseSwarmFiles } from 'swarm-mail';

// Reserve files before editing (prevents conflicts)
await reserveSwarmFiles(
  'WorkerA',
  ['src/auth/**', 'src/lib/jwt.ts'],
  { reason: 'bd-123.2: Auth service implementation' }
);

// Do work...

// Release when done
await releaseSwarmFiles('WorkerA');
```

### Event Sourcing (swarm-mail)

```typescript
import { getSwarmMail } from 'swarm-mail';

// Get swarm mail instance (PGLite adapter)
const swarmMail = await getSwarmMail('/my/project');

// Append events
await swarmMail.appendEvent({
  type: 'agent_registered',
  agent_name: 'WorkerA',
  task_description: 'Implementing auth service',
  timestamp: Date.now(),
});

// Query projections
const agents = await swarmMail.getAgents();
const messages = await swarmMail.getInbox('WorkerA', { limit: 5 });
```

### Durable Primitives (swarm-mail + Effect-TS)

```typescript
import { DurableMailbox, DurableLock, ask } from 'swarm-mail';
import { Effect } from 'effect';

// Actor mailbox
const mailbox = DurableMailbox.create<MyMessage>('worker-a');
await Effect.runPromise(
  mailbox.send({ type: 'task', payload: 'implement feature' })
);

// File locking with automatic release
const lock = DurableLock.create('src/auth.ts');
await Effect.runPromise(
  lock.acquire({ ttl: 60000 }).pipe(
    Effect.flatMap(() => /* do work */),
    Effect.ensuring(lock.release())
  )
);

// Request/response pattern
const response = await Effect.runPromise(
  ask<Request, Response>('other-agent', { type: 'get-types' })
);
```

## Technical Details

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SWARM TOOLS STACK                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TIER 3: ORCHESTRATION                                      â”‚
â”‚  â””â”€â”€ OpenCode Plugin (beads, swarm, skills, learning)      â”‚
â”‚                                                             â”‚
â”‚  TIER 2: COORDINATION                                       â”‚
â”‚  â”œâ”€â”€ DurableMailbox - Actor inbox with typed envelopes     â”‚
â”‚  â”œâ”€â”€ DurableLock - CAS-based mutual exclusion              â”‚
â”‚  â””â”€â”€ ask<Req, Res>() - Request/Response (RPC-style)        â”‚
â”‚                                                             â”‚
â”‚  TIER 1: PRIMITIVES                                         â”‚
â”‚  â”œâ”€â”€ DurableCursor - Checkpointed stream reader            â”‚
â”‚  â””â”€â”€ DurableDeferred - Distributed promise                 â”‚
â”‚                                                             â”‚
â”‚  STORAGE                                                    â”‚
â”‚  â””â”€â”€ PGLite (Embedded Postgres) + Event Sourcing           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Philosophy

**Primitives, not frameworks.** Each package solves one problem well.

- **Composable** - Mix and match what you need
- **Zero lock-in** - Works with any agent framework
- **Type-safe** - Full TypeScript with Zod schemas
- **Local-first** - PGLite embedded database, no external servers
- **Fast** - Bun-native, minimal dependencies

## Next Steps

**Get Started:**
- [Quickstart](/docs/getting-started/quickstart) - Install the plugin and run your first swarm
- [Philosophy](/docs/getting-started/philosophy) - Why Swarm Tools exists

**Using the Plugin:**
- [OpenCode Plugin Tools](/docs/packages/opencode-plugin) - All 40+ tools (beads, swarm, skills)
- [Concepts](/docs/concepts) - Event sourcing, actor model, learning systems

**Building Your Own:**
- [swarm-mail Package](/docs/packages/swarm-mail) - Event sourcing primitives and actor-model API
- [Decisions](/docs/decisions) - Architecture Decision Records (ADRs)

**Historical:**
- [Roadmap](/docs/archive/roadmap) - Future plans and experimental features
- [Credits](/docs/archive/credits) - People and projects that inspired this work

## Community

- **Website:** [swarmtools.ai](https://swarmtools.ai)
- **GitHub:** [joelhooks/opencode-swarm-plugin](https://github.com/joelhooks/opencode-swarm-plugin)
- **npm:** [opencode-swarm-plugin](https://www.npmjs.com/package/opencode-swarm-plugin), [swarm-mail](https://www.npmjs.com/package/swarm-mail)

## License

MIT - Use freely in commercial and open-source projects.
